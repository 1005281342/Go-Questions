## GC 的认识

### 1. 什么是 GC，有什么作用？Go 语言的 GC 使用的什么？

GC，全称 Garbage Collection，即垃圾回收，是一种自动内存管理的机制。当程序向操作系统申请的内存不再需要时，垃圾回收主动将其回收并供其他代码进行内存申请时候复用，或者将其归还给操作系统，这种针对内存级别的资源的自动回收过程，即为垃圾回收，而负责垃圾回收的程序组件，即为垃圾回收器。垃圾回收其实一个完美的“Simplicity is Complicated”的例子。一方面程序员受益于 GC，无需操心、也不再需要对内存进行手动的申请和释放操作，GC 在程序运行时自动释放残留过多的内存。另一方面 GC 对程序员几乎不可见，仅在需要程序进行特殊优化时候，通过提供可调控的 API，对 GC 的运行时机、运行开销进行把控时候才得以现身。

通常，垃圾回收器的执行过程通常被划分为两个半独立的组件：

- 赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是对象图（对象之间引用关系的一个有向图）进行操作。
- 回收器（Collector）：负责执行垃圾回收的代码。

Go 的 GC 目前使用的是无分代、不整理、与用户代码并发执行的三色标记清扫算法。

### 2. 常见的 GC 实现方式有哪些？

所有的 GC 算法其存在形式可以归结为追踪（Tracing）和引用计数（Reference Counting）这两种形式的混合运用。目前比较常见的 GC 实现方式包括：

#### 标记清扫

TODO

#### 标记整理

TODO

#### 复制式

TODO

#### 引用计数式

TODO

#### 分代式

TODO

#### 增量式

TODO

#### RC Immix

TODO

#### G1

TODO

### 3. 根对象到底是什么？

根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：
1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的那些变量
2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的内存区块的指针
3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的内存区块

### 4. 三色标记法是什么？Go 如何实现？三色标记法的优势是什么？

理解三色标记法的关键是理解对象的颜色抽象以及波面（wavefront）推进这一概念。从垃圾回收器的视角来看，三色抽象规定了三种不同类型的对象，并用不同的颜色相称：

- 白色对象：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象：已被回收器访问到的对象，其中所有字段都已扫描，黑色对象中任何一个指针都不可能直接指向白色对象。

这样三种不变性所定义的回收过程其实是一个波面不断前进的过程，这个波面同时也是黑色对象和白色对象的边界，灰色对象就是这个波面。

### 5. STW 是什么，Go 为什么要一直尝试减少 STW 时间，真那么有用吗？

STW 是 Stop the World 的缩写，即万物静止，是指在垃圾回收过程中为了保证实现的正确性、防止无止境的内存增长等问题不可避免的需要停止赋值器进一步操作对象图的一段过程。在这个过程中整个用户代码被停止或者放缓执行，可想 STW 越长，对用户代码造成的影响（例如延迟）就越大，早期 Go 对垃圾回收器的实现中 STW 长达几百毫秒，可想着对时间敏感的实时通信等应用程序会造成巨大的影响。

### 6. 有了 GC，为什么还会发生内存泄露？

在一个具有 GC 的语言中，常说的内存泄漏严谨的来说应该描述为：预期的能很快被释放的内存由于附着在了长期存活的内存上、或生命期意外的被延长，从而预计能够立即回收的内存而长时间得不到回收。在 Go 中，由于 goroutine 的存在，所谓的内存泄漏除了附着在长期对象上之外，还存在多种不同的形式。

- 形式1：预期能被快速释放的内存因被根对象引用而没有得到迅速释放。当有一个全局对象时，可能不经意间将某个变量附着在其上，且忽略的将其进行释放，则该内存永远不会得到释放。例如：

```go
var cache map[interface{}]interface{}
func main() {
  for i := 0; i < 100000; i++ {
    m := make([]byte, 1<<10)
    cache[i] = m
  }
}

- 形式2：goroutine 泄漏。goroutine 作为一种逻辑上理解的轻量级线程，需要维护用户代码的执行上下文信息，因此它在运行时中也需要消耗一定的内存来保存这类信息。而这些内存在目前版本（Go 1.14）的 Go 中是不会被释放的。因此，如果一个程序持续不断的产生新的 goroutine、且不结束执行已经创建的 goroutine 并复用这部分内存，则会造成内存泄漏的现象，例如：

```go
import (
    "os"
    "runtime/trace"
)
func main() {
    trace.Start(os.Stderr)
    defer trace.Stop()
    for i := 0; i < 100000; i++ {
        go func() {
            select{}
        }
    }
}
```

```shell
go run main.go 2> trace.out
```

这种 goroutine形式的泄漏还可能由 channel 泄漏导致。channel 的泄漏本质上与 goroutine 泄漏存在直接联系。channel 作为一种同步原语，会连接两个不同的 goroutine，如果一个 goroutine 尝试向一个没有接收方的无缓冲 channel 发送消息，则该 goroutine 会被永久的休眠，整个 goroutine 及其执行栈都得不到释放。

### 7. 标记清除法和并发标记清除法的区别是什么？

在没有用户态代码并发修改三色抽象的情况下，回收可以正常结束。但并发回收的根本问题在于，用户态代码在回收过程中会并发的更新对象图，从而赋值器和回收器可能对对象图的结构产生不同的认知，这时以一个固定的三色波面作为回收过程前进的边界则不再合理。

我们不妨考虑赋值器的写操作，假设某个灰色对象 A 指向白色对象 B，而此时赋值器并发的将黑色对象 C 指向（ref3）了白色对象 B，并将灰色对象 A 对白色对象 B 的引用移除（ref2），则在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象）。进而产生被错误回收的对象 B。

总而言之，并发标记清除中面临的一个根本问题就是如何使标记与清除过程保证其正确性。

8. 什么是写屏障、混合写屏障，如何实现？

要讲清楚写屏障，就需要理解三色标记清扫算法中的强弱不变性以及赋值器的颜色。
写屏障、混合写屏障是一个在并发垃圾回收器才会出现的概念，如前面所说，无条件的标记清扫可能导致对象出现丢失。从原理上讲，当以下两个条件同时满足时会导致对象丢失：

- 条件 1: 赋值器将某一白色对象引用写入黑色对象；
- 条件 2: 从灰色对象出发，到达白色对象的路径被赋值器破坏。

因此只要能够避免其中任何一个条件，则不会出现对象丢失。我们不妨将三色不变性所定义的波面根据这两个条件进行削弱，当满足原有的三色不变性定义的情况称为强三色不变性（strong tricolor invariant），即不存在黑色对象指向白色对象的指针；当赋值器在黑色对象中写入对白色对象的引用时（条件 1）的情况称为弱三色不变性（weak tricolor invariant），即所有黑色对象引用的白色对象都处于灰色保护状态（直接或间接从灰色对象可达）。当赋值器进一步破坏灰色对象到达白色对象的路径时（条件 2），即打破弱三色不变性，则也就破坏了回收器的正确性。

可见，在破坏强弱三色不变性时必须引入额外的辅助操作。

如果我们考虑并发的用户态代码，回收器不允许同时停止所有赋值器，就是涉及了存在的多个不同状态的赋值器。从而我们可以引入赋值器的颜色：

- 黑色赋值器：已经由回收器扫描过（回收器已完成根集合的追踪）不会再次对其进行扫描
- 灰色赋值器：尚未被回收器扫描过（回收器的根集合尚未被追踪到），或尽管已经扫描过但仍需要重新扫描

赋值器的颜色对回收周期的结束产生影响。如果某种并发回收器允许灰色赋值器的存在，则必须在回收结束之前重新扫描赋值器的根。如果重新扫描过程中发现了新的灰色或白色对象，回收器还需要对新发现的对象进行追踪，但是在新追踪的过程中，赋值器仍然可能在其根中插入新的非黑色引用，如此往复。因此允许灰色赋值器存在的算法，最差情况下，回收器只能将所有赋值器线程挂起才能完成其根的完成扫描，也就是我们所说的 STW。

在确保强弱三色不变性的并发指针更新操作需要通过赋值器屏障技术来保证指针的读写操作一致。因此我们所说的写屏障、混合写屏障是指赋值器的写屏障。

Go 使用的是一种灰色赋值器 Dijkstra 插入屏障和黑色赋值器 Yuasa 删除屏障混合而成的写屏障，这种形式的屏障将强三色不变性削弱为弱三色不变性，进而避免了允许灰色赋值器存在的重新扫描。混合写屏障的基本思想是：对正在被覆盖的对象进行着色，且如果当前栈尚未被扫描，则同样对安插的指针进行着色，其实现的伪代码如下：

```go
// 混合写屏障
func writePointer(slot, ptr unsafe.Pointer) {
    shade(*slot)                // 对正在被覆盖的对象进行着色，通过将唯一指针从堆移动到栈来防止赋值器隐藏对象。
    if current stack is grey {  // 如果当前 goroutine 执行栈还未被扫描为黑色
        shade(ptr)              // 则对引用进行着色，通过将唯一指针从栈移动到堆中的黑色对象来防止赋值器隐藏对象
    }
    *slot = ptr
}
```

对于弱三色不变性而言，只要存在一个能够通向白色对象的路径，黑色对象就能允许直接引用白色对象。而对于写屏障而言，总是会防止赋值器去隐藏某个对象。比如，对于 Dijkstra 屏障而言，赋值器总是可以通过将一个单一的指针移动到某个已经被扫描后的栈，从而导致某个白色对象被标记为灰色进而隐藏到黑色对象之下，进而需要对栈的重新扫描，甚至导致栈总是灰色的。

## GC 的实现细节

### 9. Go 语言中 GC 的流程是什么？

当前版本的 Go （1.14）以 STW 为界限，可以将 GC 划分为五个阶段：
 
| 阶段 | 说明 | 状态 |
|:---:|:----:|:----:|
| GCMark | 标记准备阶段，为并发标记做准备工作，启用写屏障 | STW |
| GCMark | 扫描标记阶段，与赋值器并发执行 | 并发 |
| GCMarkTermination | 标记终止阶段，保证一个周期内标记任务完成，关闭写屏障 | STW |
| GCoff | 内存清扫阶段，将需要回收的内存归还到堆中 | 并发 |
| GCoff | 内存归还阶段，将过多的内存归还给操作系统 | 并发 |

### 10. 触发 GC 的时机是什么？

Go 语言中对 GC 的触发时机存在两种形式：
1. 被动触发，分为两种方式：
  - 使用的是步调（Pacer）算法，其核心思想是控制内存增长的比例，通过 GOGC 或者 debug.SetGCPercent 进行控制。不妨设上一次 GC 完成时，内存的数量为 A，而控制的比例为 P，则 GC 会试图在内存总量达到 A * (1+P) 时完成下一次 GC 的执行。
  - 使用系统监控， 当超过两分钟没有产生任何 GC 时，强制触发 GC。
2. 主动触发，通过调用 runtime.GC 来触发 GC，此调用阻塞式的等待当前 GC 运行完毕。

### 11. 如果内存分配速度超过了标记清除的速度怎么办？是怎么实现的？

目前的 Go 实现中，当 GC 触发后，会首先进入并发标记的阶段。并发标记会设置一个标志，并在 mallocgc 调用进行检查。当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记的工作（Mark Assist），从而达到放缓继续分配、辅助 GC 的标记工作的目的。
GC 的优化问题

### 12. 如何观察 Go GC？

观察 Go 的 GC 目前由四种不同的方式：
- GODEBUG=gctrace=1
- debug.ReadGCStats
- runtime.ReadMemStats
- go tool trace

### 13. GC 关注的指标有哪些？

Go 中的 GC 被设计为成比例触发、大部分工作与赋值器并发、不分代、无内存移动且会主动向操作系统归还申请的内存。因此最主要关注的能够影响赋值器的性能指标有：

- CPU 利用率：回收算法会在多大程度上拖慢程序？有时候，这个是通过回收占用的 CPU 时间与其它 CPU 时间的百分比来描述的。
- GC 停顿时间：回收器会造成多长时间的停顿？
- GC 停顿频率：回收器造成的停顿频率是怎样的？
- GC 可扩展性：当堆内存变大时，垃圾回收器的性能如何

### 14. Go 的 GC 如何调优？

所谓 GC 的调优的核心思想是：优化内存的申请速度，尽可能的少申请内存，复用已申请的内存（例如 sync.Pool）。Go 自身提供的调试工具（go tool pprof 与 go tool trace）能够快速帮助我们定位存在大量内存申请的位置。

#### 例1 TODO
#### 例2 TODO
#### 例3 TODO

#### 总结

1. 减少返回会逃逸到堆上分配的变量，是变量作为局部变量进行分配，从而可以直接在不被垃圾回收进行清理的情况下，使整个栈供下一个 goroutine 复用。
2. 将小对象整理为一个大对象来避免内存碎片的问题
3. 使用 sync.Pool 来复用需要频繁创建临时对象
4. 使用 goroutine 池，避免短时间内大量创建 goroutine 导致的不可逆的性能下降

### 15. Go 的垃圾回收器有哪些相关的 API？其作用与目标分别是什么？

在 Go 中存在数量极少的与 GC 相关的 API，它们是

- runtime.GC
- debug.FreeOSMemory
- debug.ReadGCStats
- debug.SetGCPercent
- debug.SetMaxHeap（尚未发布）

## GC 的历史及演进

### 16. Go 历史各个版本在 GC 方面的改进？

- Go 1：串行三色标记清扫
- Go 1.1：并行清扫，标记过程需要 STW，停顿时间在约几百毫秒
- Go 1.5：并发标记清扫，停顿时间在一百毫秒以内
  ![https://twitter.com/brianhatfield/status/634166123605331968?lang=en](./assets/1.png)
- Go 1.6：使用 bitmap 来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在十毫秒以内
  - 从 1.5 切换到 1.6 时的停顿时间对比 
    ![https://twitter.com/brianhatfield/status/692778741567721473/photo/1](./assets/2.jpeg)
  - 从 1.6 切换到 1.6.3 时的停顿时间对比 
    ![https://twitter.com/brianhatfield/status/767812346760859648/photo/1](./assets/3.jpeg)
  - 包括 CPU 使用率的一些改进 
    ![https://twitter.com/brianhatfield/status/768788316347068416/photo/1](./assets/4.jpeg)
- Go 1.7：停顿时间控制在两毫秒以内
  - 从 1.6.3 切换到 1.7 时的停顿时间对比
    ![https://twitter.com/brianhatfield/status/767890817587539968/photo/1](./assets/5.jpeg)
- Go 1.8：混合写屏障，停顿时间在半个毫秒左右
  - ![https://twitter.com/brianhatfield/status/804355831080751104/photo/1](./assets/6.jpeg)

              
            
- Go 1.9：彻底移除了栈的重扫描过程
  - 消除栈重扫
    与 1.8.3 几乎一致 ![https://twitter.com/brianhatfield/status/900473287750365184/photo/1](./assets/7.jpeg)
- Go 1.12：整合了两个阶段的 Mark Termination，但引入了一个严重的 GC Bug 至今维修，尚无该 Bug 对 GC 性能影响的报告
- Go 1.13：着手解决向操作系统归还内存的，提出了新的 Scavenger
- Go 1.14：替代了仅存在了一个版本的 scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题

可以用下图直观说明 GC 的演进历史：

![](assets/gc1.png)
![](assets/gc2.png)
![](assets/gc3.png)

### 17. Go GC 在演化过程中还存在那些其他设计？为什么他们没有被接受？

#### 并发栈重扫

TODO

#### ROC

TODO

### 18. 目前提供 GC 的语言以及不提供 GC 的语言有哪些？GC 和 No GC 各自的优缺点是什么？

从原理上而言，所有的语言都能够自行实现 GC，但从语言诞生之初就提供 GC 的语言例如：

- Python
- JavaScript
- Java
- Objective-C
- Swift

而不已 GC 为目标，被直接设计为手动管理内存、但可以自行实现 GC 的语言有：

- C
- C++

也有一些语言可以在编译期，依靠编译器插入清理代码的方式，实现精准的清理，例如 

- Rust

垃圾回收使程序员无需手动处理内存释放。从而能够消除一些需要手动管理内存才会出现的运行时错误：

1. 当在仍然有指向内存区块的指针的情况下释放这块内存时，会产生悬挂指针，从而后续可能错误的访问已经用做他用的内存区域。
2. 多重释放同一块申请的内存区域可能导致不可知的内存损坏。

当然，垃圾回收也会伴随一些缺陷，这也就造就了没有 GC 的一些优势：

3. 没有额外的性能开销
4. 精准的手动内存管理，极致的利用机器的性能

### 19. Go 对比 Java、V8 中 JavaScript 的 GC 性能如何？

无论是 Java 还是 JavaScript 中的 GC 均为分代式 GC。分代式 GC 的一个核心假设就是分代假说：将对象依据存活时间分配到不同的区域，每次回收只回收其中的一个区域。

#### V8 的 GC

在V8中主要将内存分为新生代和老生代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存、或者占用内存较大的对象：

1. 新生代中的对象主要通过副垃圾回收器进行回收。该回收过程是一种采用复制的方式实现的垃圾回收算法，它将堆内存一分为二，这两个空间中只有一个处于使用中，一个处于闲置状态。处于是使用状态的空间称为From空间，处于闲置的空间称为To空间。分配对象时，先是在From空间中进行分配，当开始垃圾回收时，会检查From空间中的存活对象，并将这些存活对象复制到To空间中，而非存活对象占用的空间被释放。完成复制后，From空间和To空间的角色互换。即就是通过将存活对象在两个空间中进行复制。
2. 老生代则由主垃圾回收器负责。它的实现的是标记清扫过程，但略有不同之处在于它还会在清扫完成后对内存碎片进行整理，进而是一种标记整理的回收器。

#### Java 的 GC

Java 的 GC 称之为 G1，并将整个堆分为年轻代、老年代和永久代。包括四种不同的收集操作，根据代码行为选择性与配置选择性进行：

1. 年轻代收集周期
2. 老年代收集周期
3. 混合式收集周期
4. 完整 GC 周期
5. 在回收过程中，G1 会对停顿时间进行预测，调整 GC 的策略从而达到用户代码对停顿时间的要求。这四个周期的执行成本逐渐上升，优化得当的程序可以完全避免完整 GC 周期。

#### 性能比较

在 Go、Java 和 V8 JavaScript 之间比较 GC 的性能本质上是一个不切实际的问题。如前面所说，垃圾回收器的设计权衡了相当多方面的因素，除此之外同时还受语言自身设计的影响，因为语言的设计也直接影响了程序员编写代码的形式，也就自然影响了产生垃圾的方式。
但总的来说，他们三者对垃圾回收的实现都需要 STW，并均已达到了用户代码几乎无法感知到的状态（小于一毫秒）。当然，随着 STW 的减少，垃圾回收器会增加 CPU 的使用率，这也是程序员在编写代码时需要手动进行优化的部分，即充分考虑内存分配的必要性，减少过多申请内存带给垃圾回收器的压力。
